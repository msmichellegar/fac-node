<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' />
  <title>Big</title>
  <link href='big.css' rel='stylesheet' type='text/css' />
  <link href='highlight.css' rel='stylesheet' type='text/css' />
  <style>
    .new-shiny { background: #aaaaaa; }
  </style>
  <script src='big.js'></script>
  <script src='highlight.js'></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body class='light'>

  <!-- introduction to ME -->
  <div>The Unbearable Lightness of <em>node_modules</em></div>
  <div>
    Michelle Garrett
    <em>Cond√© Nast International</em>
    @msmichellegar
  </div>

  <!-- introduction to the talk, brief overview -->
  <div>node_modules</div>
  <div>How can we be responsible curators of our node_modules?</div>
  <!-- Today I'm here to talk about node_modules: my favourite directory in an application. I'm going to be talking about how we choose what goes into our node_modules directory, and how we can be responsible owners and curator of our node_modules. -->

  <div>
    <img src="./images/nodeschool.jpg">
  </div>
  <!-- This is weird, because when I first learned Node (at NodeSchool) a few years ago, I was told that one of the best parts about writing Node was having access to this amazing ecosystem of code that other people have written and that I can use for free. I thought that was really cool. The first packages I installed were things like Hapi and Express and nodemon and they made my life so much better. -->

  <div>Dependencies are bad?</div>
  <div>organic vegan javascript</div>
  <!-- But after I existed in the Node world for awhile, I started to hear that dependencies are bad, and I should actually use as few node modules as possible. We're bloating our applications with frivolous packages, and we should just be writing organic vegan gluten-free JavaScript without any dependencies. -->

  <div>How do I know if a package is good enough to npm install?</div>
  <div>If I'm comparing two packages that do the same thing, how do I choose between them?</div>
  <!-- This has made me think...if space in my application is so valuable, how do I assess if an npm package is going to be good enough to install? And if I'm comparing two different packages that essentially do the same thing, how do I choose between them? Do I choose the popular one that was on Hacker News all the cool kids are using? Or do I go with a weird lightweight alternative that only has 100 stars on GitHub? -->

  <div>
    <h3>I'll be talking about:</h3>
    <ul style="margin-top: 20px;">
      <li>The cost of modules</li>
      <li>Criteria to evaluate them</li>
      <li>Some alternatives to popular modules (road testing this criteria)</li>
    </ul>
  </div>
  <!-- In my talk today I'm going to talk about the cost of modules, I'm going to propose some criteria we can use to evaluate them, and we're going to assess some lightweight alternatives to popular Node modules to test out these ideas. Hopefully by the end of this you'll have everything you need to a make more informed decision about adding something new to your package.json file. -->

  <!-- Cost of modules  -->

  <div>What is the cost of a module?</div>
  <!-- To start with, I want to talk about the cost of bringing a module into your project. What is the actual footprint of an npm install? What's so bad about installing one more package? -->

  <div>Size</div>
  <div>(I think we put too much emphasis on size over other factors for server side modules.)</div>
  <!-- Let's start with one of the most talked about impacts: Size. This is the one that we hear the most about. But when I actually looked into about it, it didn't really seem like the biggest issue for server side code. If a module is going to be used on the frontend, say in a React app, then you should definitely check the impact it has on your bundle size. But working with Node, modules are really just files in your server until you use them. I came to the conclusion that we put too much emphasis on size over other factors when choosing modules for server side development. -->

  <div>Complexity</div>
  <div>More dependencies means more things than can break and introduce security vulnerabilities.</div>
  <!-- More important than this, I think, is considering the added complexity a new module brings to your codebase. More dependencies means more things that can break (and introduce security vulnerabilities). And when dependencies have dependencies of their own, things get further from your control, and problems get harder to find. -->

  <div>Technical costs are real, but <em>consider the human cost</em> of adding a dependency.</div>
  <!-- Technical costs are real, but I think it's more important to think about  the human cost of adding a dependency. Every extra package is going to impact your experience as a developer in some way, and also impact the experience of those you work with. -->

  <div>Installing a module ties you to a community.</div>
  <!-- Adding a module is making an investment in a particular community. And how good or active that community is can have a serious impact on your developer experience. You're going to be at the mercy of that project's maintainers every time you report a bug and need it fixed. -->

  <div>Installing a module raises the barrier to entry for your code base.</div>
  <!-- Installing a module also raises the barrier to entry for your code base. If you install a new library, you increase the number of things a new starter on your team will have to know in order to be productive. Now, they don't just have to know how to write Node, they also have to know how to work with another specific API that they might not have seen before and will have to research. This isn't always a big deal, and having to research things is part of being a software developer. But the added cost is undeniable. -->

  <!-- Benefits -->

  <div>(But I actually do love node modules.)</div>
  <div>There are problems a wider community of people can solve that you or your team can't (or shouldn't) tackle alone.</div>
  <!-- But it's not all bad. In fact I LOVE node modules, and there are many reasons you SHOULD be using other people's code instead of writing your own. There are problems that a wider community of people can solve that you or your small team can't tackle on your own. -->

  <!-- Criteria. -->

  <div>My criteria:</div>
  <!-- So with this in mind, I'm going to propose some criteria I think is important for evaluating packages. -->

  <div>(Of course this is different for every project).</div>
  <!-- Of course evaluating modules will be different depending on your project aims and size. For a hobby project, you don't necessarily need to even care about a lot of this. But if you're building a production website with thousands or millions of users, these are the things that should probably be on your mind. -->

  <!-- Let's start with the more technical ones. Controversial, but we're actually just going to ignore size. -->

  <div>How intuitive is the API?</div>
  <!-- How intuitive is the API? How many lines of code does it take to do a thing? I want a module to have a straightforward API that I can easily use and understand. I want methods with names that reflect what they actually do. I want the module to make my life easier than if I were to implement something myself in pure Node. -->

  <div>Are there tests?</div>
  <!-- Are there tests? If I'm going to use someone else's code, I want it to be good. Tests aren't foolproof, but they go some of the way towards giving me the peace of mind that this package is not going to break my website in production.. -->

  <!-- Now let's talk about some more human criteria. -->

  <div>What are the docs like?</div>
  <!-- What are the docs like? I want to be able to learn how to use an API without going digging in the source code. I want to know all the available methods, what parameters they take, and what they return. A quick start guide is particularly useful. And ideally there'll be examples of how to use the module in different situations. If there's a tutorial, that's even better. -->

  <div>Is it maintained?</div>
  <!-- Is it maintained? This is pretty essential. I need a GitHub repo to show some signs of life from the last few months. This means commits, issues responded to and closed, contributions accepted, and new releases. I want to see reported problems being dealt with. Of course maintaining software takes a lot of effort, and I respect the time of the people who are pouring their efforts into open source projects. So if the sole creator of the module doesn't want to actively maintain it, I want to see them engaging members of the community who will. -->

  <div>Are there people using it?</div>
  <!-- Are there people using it? Number of npm installs and GitHub stars is not always synonymous with quality, but it does mean there are more people out there to answer your StackOverflow questions. It's handy to be able to read other's people's code and blog posts for a particular package, and for there to be other people raising issues before you run into them yourself. Usually the more people using a module, the better it is for you. -->

  <div>
    <h3>Evaluating a module:</h3>
    <ul style="margin-top: 20px;">
      <li>Is the API intuitive?</li>
      <li>Are there tests?</li>
      <li>What are the docs like?</li>
      <li>Is it maintained?</li>
      <li>Are there people using it?</li>
    </ul>
  </div>

  <div>Dependencies are like puppies. You don't install a module, you adopt it.</div>
  <!-- road tests -->

  <div>Let's compare some packages.</div>
  <!-- Ok so let's put this into practice, and road test some packages. I'm going to show you some self-professed "lightweight" alternatives that I tried for popular node modules. And we'll assess if it's worth npm installing something a little bit off the beaten track. -->

  <div>
    <h3>More alternatives:</h3>
    <ul style="margin-top: 20px;">
      <li>Use Lodash? Try <em>Lazy.js.</em></li>
      <li>Use Request? Try <em>Got.</em></li>
      <li>Use Winston? Try <em>Bunyan.</em></li>
    </ul>
  </div>
  <!-- Thanks for sticking with me in those two comparisons. There are so many more lightweight alternatives to popular modules that it would be fun to explore. Here are some of my suggestions. If you have the time, it's really worth exploring and not always going for the obvious option. -->

  <div>
    <h3>What I learned:</h3>
    <ul style="margin-top: 20px;">
      <li>Sometimes it's worth exploring less popular alternatives.</li>
      <li>Dependencies have a technical and human cost, and you should consider both.</li>
      <li>Well-maintained projects are almost always the better option.</li>
    </ul>
  </div>
  <!-- So. What have I learned about choosing my npm modules? These were my key takeaways:
    - Dependencies have a technical and human cost, and you should consider both
    - Well-maintained projects are almost always the better option
  -->

  <div>
    <h3>Useful tools:</h3>
    <ul style="margin-top: 20px;">
      <li><em>npmcompare.com</em> (popularity and maintenance)</li>
      <li><em>npmtrends.com</em> (popularity over time)</li>
      <li><em>david-dm.org</em> (security of dependencies)</li>
      <li><em>cost-of-modules</em> (size of dependencies)</li>
    </ul>
  </div>
  <!-- If you're looking for some ways to evaluate packages without digging through the repos yourself, I recommend the following tools:
    - npmcompare.com (for a top level overview of popularity and maintenance)
    - npmtrends.com (to see popularity over time)
    - David.dm (for checking the security of a project's dependencies)
    - cost-of-modules (npm package to tell you size of all your modules and their dependencies)
  -->

  <div>jsdrag.now.sh</div>
  <!-- I've put my JavaScript drag queen name generator online, using the Sequelize code. If you're looking to generate your own JavaScript drag queen name, you can go to bit.ly/jsdragqueen, and claim yours right now. -->

  <div>
    <em>Thank you!</em>
    <p>@msmichellegar</p>
  </div>
  <!-- Thanks everyone! -->
  <script src="highlight.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
    console.log('fmewiofmewio')
  </script>
</body>
</html>
