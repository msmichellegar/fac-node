<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' />
  <title>Big</title>
  <link href='big.css' rel='stylesheet' type='text/css' />
  <link href='highlight.css' rel='stylesheet' type='text/css' />
  <style>
    .new-shiny { background: #aaaaaa; }
  </style>
  <script src='big.js'></script>
  <script src='highlight.js'></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body class='light'>

  <!-- introduction to ME -->
  <div>The Unbearable Lightness of <em>node_modules</em></div>
  <div>
    Michelle Garrett
  </div>
  <div><em>Cond√© Nast International</em></div>
  <div>@msmichellegar</div>

  <!-- introduction to the talk, brief overview -->
  <div>node_modules</div>
  <div>How can we be responsible curators of our node_modules?</div>
  <!-- Today I'm here to talk about node_modules: my favourite directory in an application. I'm going to be talking about how we choose what goes into our node_modules directory, and how we can be responsible owners and curator of our node_modules. -->

  <div>JavaScript</div>
  <div>panic</div>
  <div>too many dependencies</div>
  <!-- In recent times I've been thinking a lot about how valuable the space is in our node_modules directory. This is probably because recently I've absorbed a lot of the general JavaScript panic about having too many dependencies.-->

  <div>
    <img src="./images/nodeschool.jpg">
  </div>
  <!-- This is weird, because when I first learned Node (at NodeSchool) a few years ago, I was told that one of the best parts about writing Node was having access to this amazing ecosystem of code that other people have written and that I can use for free. I thought that was really cool. The first packages I installed were things like Hapi and Express and nodemon and they made my life so much better. -->

  <div>Dependencies are bad?</div>
  <div>organic vegan javascript</div>
  <!-- But after I existed in the Node world for awhile, I started to hear that dependencies are bad, and I should actually use as few node modules as possible. We're bloating our applications with frivolous packages, and we should just be writing organic vegan gluten-free JavaScript without any dependencies. -->

  <div>How do I know if a package is good enough to npm install?</div>
  <div>If I'm comparing two packages that do the same thing, how do I choose between them?</div>
  <!-- This has made me think...if space in my application is so valuable, how do I assess if an npm package is going to be good enough to install? And if I'm comparing two different packages that essentially do the same thing, how do I choose between them? Do I choose the popular one that was on Hacker News all the cool kids are using? Or do I go with a weird lightweight alternative that only has 100 stars on GitHub? -->

  <div>
    <h3>I'll be talking about:</h3>
    <ul style="margin-top: 20px;">
      <li>The cost of modules</li>
      <li>Criteria to evaluate them</li>
      <li>Some alternatives to popular modules</li>
    </ul>
  </div>
  <!-- In my talk today I'm going to talk about the cost of modules, I'm going to propose some criteria we can use to evaluate them, and we're going to assess some lightweight alternatives to popular Node modules to test out these ideas. Hopefully by the end of this you'll have everything you need to a make more informed decision about adding something new to your package.json file. -->

  <!-- Cost of modules  -->

  <div>What is the cost of a module?</div>
  <!-- To start with, I want to talk about the cost of bringing a module into your project. What is the actual footprint of an npm install? What's so bad about installing one more package? -->

  <div>Size</div>
  <div>(I think we put too much emphasis on size over other factors for server side modules.)</div>
  <!-- Let's start with one of the most talked about impacts: Size. This is the one that we hear the most about. But when I actually looked into about it, it didn't really seem like the biggest issue for server side code. If a module is going to be used on the frontend, say in a React app, then you should definitely check the impact it has on your bundle size. But working with Node, modules are really just files in your server until you use them. I came to the conclusion that we put too much emphasis on size over other factors when choosing modules for server side development. -->

  <div>Complexity</div>
  <div>More dependencies means more things than can break and introduce security vulnerabilities.</div>
  <!-- More important than this, I think, is considering the added complexity a new module brings to your codebase. More dependencies means more things that can break (and introduce security vulnerabilities). And when dependencies have dependencies of their own, things get further from your control, and problems get harder to find. -->

  <div>Technical costs are real, but <em>consider the human cost</em> of adding a dependency.</div>
  <!-- Technical costs are real, but I think it's more important to think about  the human cost of adding a dependency. Every extra package is going to impact your experience as a developer in some way, and also impact the experience of those you work with. -->

  <div>Installing a module ties you to a community.</div>
  <!-- Adding a module is making an investment in a particular community. And how good or active that community is can have a serious impact on your developer experience. You're going to be at the mercy of that project's maintainers every time you report a bug and need it fixed. -->

  <div>Installing a module raises the barrier to entry for your code base.</div>
  <!-- Installing a module also raises the barrier to entry for your code base. If you install a new library, you increase the number of things a new starter on your team will have to know in order to be productive. Now, they don't just have to know how to write Node, they also have to know how to work with another specific API that they might not have seen before and will have to research. This isn't always a big deal, and having to research things is part of being a software developer. But the added cost is undeniable. -->

  <!-- Benefits -->

  <div>(But I actually do love node modules.)</div>
  <div>There are problems a wider community of people can solve that you or your team can't (or shouldn't) tackle alone.</div>
  <!-- But it's not all bad. In fact I LOVE node modules, and there are many reasons you SHOULD be using other people's code instead of writing your own. There are problems that a wider community of people can solve that you or your small team can't tackle on your own. -->

  <!-- Criteria. -->

  <div>My criteria:</div>
  <!-- So with this in mind, I'm going to propose some criteria I think is important for evaluating packages. -->

  <div>(Of course this is different for every project).</div>
  <!-- Of course evaluating modules will be different depending on your project aims and size. For a hobby project, you don't necessarily need to even care about a lot of this. But if you're building a production website with thousands or millions of users, these are the things that should probably be on your mind. -->

  <!-- Let's start with the more technical ones. Controversial, but we're actually just going to ignore size. -->

  <div>How intuitive is the API?</div>
  <!-- How intuitive is the API? How many lines of code does it take to do a thing? I want a module to have a straightforward API that I can easily use and understand. I want methods with names that reflect what they actually do. I want the module to make my life easier than if I were to implement something myself in pure Node. -->

  <div>Are there tests?</div>
  <!-- Are there tests? If I'm going to use someone else's code, I want it to be good. Tests aren't foolproof, but they go some of the way towards giving me the peace of mind that this package is not going to break my website in production.. -->

  <!-- Now let's talk about some more human criteria. -->

  <div>What are the docs like?</div>
  <!-- What are the docs like? I want to be able to learn how to use an API without going digging in the source code. I want to know all the available methods, what parameters they take, and what they return. A quick start guide is particularly useful. And ideally there'll be examples of how to use the module in different situations. If there's a tutorial, that's even better. -->

  <div>Is it maintained?</div>
  <!-- Is it maintained? This is pretty essential. I need a GitHub repo to show some signs of life from the last few months. This means commits, issues responded to and closed, contributions accepted, and new releases. I want to see reported problems being dealt with. Of course maintaining software takes a lot of effort, and I respect the time of the people who are pouring their efforts into open source projects. So if the sole creator of the module doesn't want to actively maintain it, I want to see them engaging members of the community who will. -->

  <div>Are there people using it?</div>
  <!-- Are there people using it? Number of npm installs and GitHub stars is not always synonymous with quality, but it does mean there are more people out there to answer your StackOverflow questions. It's handy to be able to read other's people's code and blog posts for a particular package, and for there to be other people raising issues before you run into them yourself. Usually the more people using a module, the better it is for you. -->

  <div>
    <h3>Evaluating a module:</h3>
    <ul style="margin-top: 20px;">
      <li>Is the API intuitive?</li>
      <li>Are there tests?</li>
      <li>What are the docs like?</li>
      <li>Is it maintained?</li>
      <li>Are there people using it?</li>
    </ul>
  </div>

  <!-- road tests -->

  <div>Let's compare some packages.</div>
  <!-- Ok so let's put this into practice, and road test some packages. I'm going to show you some self-professed "lightweight" alternatives that I tried for popular node modules. And we'll assess if it's worth npm installing something a little bit off the beaten track. -->

  <!-- image processing comparison -->
  <div>Image Processing</div>
  <!-- The first genre of package we'll be trying out is for image processing. By image processing, I'm referring to a library that can transform images in various ways: cropping, resizing, rotating, adding text and overlays, changing image file type. It's a problem you'll probably come across at some point if you're building web applications. -->

  <div><img src="images/coco.png"></div>
  <!-- Needing a library to crop and edit images in Node was something I encountered at work earlier this year. We were building a Slackbot that would process images from fashion shows around the world, and deliver them to the picture editors, cropped to the right size for a particular Vogue website. -->

  <div><img src="images/chippies-new.jpg"></div>
  <!-- This time around, for the purposes of this presentation, I want to build a little app that can make me a souvenir photo from NodeConf Argentina. So I basically need a library that can add some text and sparkles to an image. -->

  <div>Imagemagick</div>
  <!-- The "popular" node module I want to explore alternatives to is Imagemagick. Although Imagemagick isn't actually one module, it's a piece of graphics processing software for which a number of npm modules have been built to work with. Imagemagick itself has been around since forever, first created in 1987 (which I'm sorry to tell you is before I was born). ImageMagick is written in C, and is primarily a command line interface. You also might have heard of GraphicsMagick, which is the fork it spawned 15 years ago. -->

  <!-- If you've done image processing, you've probably used Imagemagick. It's extremely popular, and almost the de facto option for programmers in several languages. And particularly in Node. -->

  <div><img src="images/imagemagick-results.png"></div>
  <div>gm</div>
  <!-- There are 231 different Imagemagick-related packages published on npm. The top few have over 300,000 downloads combined in the last month. The most popular of these, with 260,000 downloads, is a package called "gm". -->

  <div>"GraphicsMagick and ImageMagick for Node"</div>
  <!-- gm describes itself as "GraphicsMagick and Imagemagick for Node". It's essentially a wrapper library, providing Node bindings for Imagemagick. It allows you to use all the many methods Imagemagick provides for image processing. -->

  <div><img src="images/im-1.png"></div>
  <div><img src="images/im-2.png"></div>
  <!-- So let's get evaluating, and start by taking a look at the repo. It has nearly 5000 stars on GitHub. Some nice badges let us know that the build is passing. There's a test directory with actual tests that look legit. So far so good. -->

  <div><img src="images/im-3.png"></div>
  <!-- Unfortunately it looks like the last commit was over a year ago. There are 38 open pull requests, and the last one that was merged was in August 2016. 221 issues, with the last also being closed in August 2016. Hmm. -->

  <div><img src="images/im-4.png"></div>
  <!-- I do like the README, which is packed with examples of how to use the various methods. There's even an entire directory called "examples" which gives you code to do lots of common transforms like "resize", "blur", "sepia" or "magnify". -->

  <div><img src="images/chippies.jpg"></div>
  <!-- Anyway, let's give it a go and make my souvenir photo for NodeConf Argentina. Here's a photo from the bar last night. I want to add some sparkle emoji, and because I'm having such a good time, some nice text that says I heart NodeConf Argentina 2017. -->

  <div>
    <pre>
      <code>
        <em>gm('/images/fac12.jpg')</em>
          .font('Helvetica.ttf', 50)
          .fill('magenta')
          .gravity('South')
          .drawText(0, 30, `I <3 FAC12`)
          .out('/images/sparkle.png')
          .geometry('-170+100')
          .out('-composite')
          .write('/images/fac12-new.jpg');
        </code>
      </pre>
  </div>

  <div>
    <pre>
      <code>
        gm('/images/fac12.jpg')
          <em>.font('Helvetica.ttf', 50)
          .fill('magenta')
          .gravity('South')
          .drawText(0, 30, `I <3 FAC12`)</em>
          .out('/images/sparkle.png')
          .geometry('-170+100')
          .out('-composite')
          .write('/images/fac12-new.jpg');
        </code>
      </pre>
  </div>

  <div><img src="/fac-node/images/gm-og1.jpg"></div>

  <div>
    <pre>
      <code>
        gm('/images/fac12.jpg')
          .font('Helvetica.ttf, 50)
          .fill('magenta')
          .gravity('South')
          .drawText(0, 30, `I <3 FAC12`)
          <em>.out('/images/sparkle.png')
          .geometry('-170+100')
          .out('-composite')</em>
          .write('/images/fac12-new.jpg');
        </code>
      </pre>
  </div>

  <div>
    <pre>
      <code>
        gm('/images/fac12.jpg')
          .font('Helvetica.ttf, 50)
          .fill('magenta')
          .gravity('South')
          .drawText(0, 30, `I <3 FAC12`)
          .out('/images/sparkle.png')
          .geometry('-170+100')
          .out('-composite')
          <em>.write('/images/fac12-new.jpg');</em>
        </code>
      </pre>
  </div>

  <div><img src="images/gm-og.jpg"></div>

  <!-- Now let's get a bit wild and add some text to the image. So we're reading the image file, resizing it, now let's set the colour of the brush stroke to be white, the font to be Helvetica and 30px, let's set the "gravity" to South, which means the text will appear at the bottom of the image, and let's draw the text "I <3 NodeConf Argentina". Write it, and wow! We have a cute souvenir image! -->

  <!-- I have to say, this was a great experience for me. The methods are all very well-named, the library did everything I needed it to do. I knew exactly what methods to use by looking at the examples in documentation.  -->

  <div>So why wouldn't I use this module?</div>
  <!-- So if that was so nice, why wouldn't I use Imagemagick with gm? Well there are the initial questions I had about how well-maintained it is. It doens't look particularly promising in terms of activity in the repo. I'd really want to see a community of people contributing to keeping this going given how many downloads it has -->

  <div>External dependencies!</div>
  <div>brew install ImageMagick</div>
  <!-- But that aside, there's a catch. This module requires you install Imagemagick as an external dependency in your project. That is, outside your node_modules directory. This is something I neglected to mention. In order to run my beautiful code to create the souvenir photo, I had to `brew install ImageMagick` on my machine. And if I were to deploy this, I would have to ensure that Imagemagick was installed on the server. -->

  <div>Sharp</div>
  <div>"high performance Node.js image processing"</div>
  <!-- So let's talk about an alternative to Imagemagick with gm. I've chosen Sharp, which bills itself as "high performance Node.js image processing". It's not entirely true to call Sharp a "weird, obscure alternative", as it has over 6000 stars on GitHub, which is 1k more than the last module we looked at. But in terms of downloads, it sits at 150,000 per month, which is about half that of the most popular Imagemagick modules. So it's still the underdog here. -->

  <div>Sharp does not require you to install external dependencies</div>
  <!-- For me, the big drawcard of Sharp is the lack of external dependencies. It does not require you to install anything like Imagemagick on your machine in order to use it. You just npm install and go. So let's see if the experience of using the module is comparable to what we just looked at. -->

  <div><img src="images/sharp-1.png"></div>
  <div><img src="images/sharp-2.png"></div>
  <div><img src="images/sharp-3.png"></div>
  <!-- Once again, let's start by looking at the repo. Lots of stars, updated in the last month, only 8 open PRs, last issue closed a day ago, and all that are open have been responded to by a maintainer. There are even contributor guidelines and an .editorconfig that makes it easier for people to make pull requests. There's a nice full test folder, with different types of tests (unit AND benchmark tests). A little badge tells me there's 99% coverage. I'm very impressed! -->

  <!-- I definitely am a little bit obsessed with Sharp at this point, so let's see how different the code looks when we do what we did before with Imagemagick. -->

  <div>
    <pre>
      <code>
        <em>sharp('/images/fac12.jpg')</em>
          .overlayWith(textSVG,
            { gravity: sharp.gravity.south })
          .overlayWith('/images/sparkle.png',
            { gravity: sharp.gravity.southwest })
          .toFile('/images/fac12-new.jpg');
      </code>
    </pre>
  </div>

  <div>
    <pre>
      <code>
        sharp('/images/fac12.jpg')
          <em>.overlayWith(textSVG,
            { gravity: sharp.gravity.south })</em>
          .overlayWith('/images/sparkle.png',
            { gravity: sharp.gravity.southwest })
          .toFile('/images/fac12-new.jpg');
      </code>
    </pre>
  </div>

  <div>
    <pre>
      <code>
        sharp('/images/fac12.jpg')
          .overlayWith(textSVG,
          { gravity: sharp.gravity.south })
          <em>.overlayWith('/images/sparkle.png',
            { gravity: sharp.gravity.southwest })</em>
          .toFile('/images/fac12-new.jpg');
      </code>
    </pre>
  </div>

  <div>
    <pre>
      <code>
        sharp('/images/fac12.jpg')
          .overlayWith(textSVG,
          { gravity: sharp.gravity.south })
          .overlayWith('/images/sparkle.png',
            { gravity: sharp.gravity.southwest })
          <em>.toFile('/images/fac12-new.jpg');</em>
      </code>
    </pre>
  </div>

  <!-- Once again I can just pass the path to our image into the sharp method to intialise the process. Then exactly the same method to resize the image to 400px. -->

  <!-- When it comes to overlaying the text, Sharp required a bit more of a workaround, as there is no inbuilt method for drawing text. It wasn't too bad though, I overlayed an SVG with the text. And looking at the repo, I can see people are working on a friendlier solution for this. -->

  <div><img src="images/gm-og.jpg"></div>
  <!-- Here is my beautiful souvenir image! -->

  <div>Imagemagick or Sharp?</div>
  <!-- So which library do I prefer? -->

  <div><img src="images/chippies-emboss.jpg"></div>
  <div><img src="images/chippies-sepia.jpg"></div>
  <div><img src="images/chippies-neg.jpg"></div>
  <div><img src="images/chippies-swirl.jpg"></div>
  <!-- I discovered while exploring the API that Sharp doesn't have as many features as Imagemagick, which is a shame. ImageMagick allows me to do all sorts of wild things like turning images green, rotating them and adding borders. That makes ImageMagick unfortunately a lot more fun. But do I need a fun library for my purposes? I'm sad to say probably not. If I wanted to do something elaborate like turn photos into mosaics, or simulate Instagram filters in Node, then maybe imageMagick is a better choice, even with all of its downsides. It might be worth a few extra lines in my Dockerfile, and an external dependency. But given I mostly just need to crop an image and insert some text, I think Sharp is sufficient - and for me, a better choice. If you're doing image processing, I would definitely look to Sharp before using something like Imagemagick. -->

  <div>Underdog wins! üê∂</div>
  <!-- So in this case: yes! It is worth choosing the underdog! -->

  <!-- So, onto our second package battle! -->

  <div>ORMs (aka Object Relational Mappers)</div>
  <div>An ORM is an easier way of interacting with your database in your code.</div>
  <!-- For our second module off, we're going to be talking about ORMS. I wanted to talk about ORMs because they seem to have an "interesting" history in Node. By ORM I'm referring to an Object Relational Mapper, a framework which abstracts your datastore, and gives you an interface for interacting with it in your code. Not everyone uses ORMs, but they benefits like not writing raw SQL, less vulnerability to SQL injection, and the ability to easily switch SQL databases. -->

  <!-- I started looking for a Node ORM for MySQL last year for a project at work. -->

  <div class="boo" style="font-size: inherit !important;"><img src="images/orm.png"></div>
  <!-- I quickly fell down a trail of Reddit threads about Node ORMs, or the lack thereof. Such as this one: Has anyone used an ORM with Node.js that they actually enjoyed? Be honest please. -->

  <div><div><img src="images/orm-tweet.png"></div></div>
  <!-- I found some particularly bleak tweets about the state of ORMs in Node.js. Here's my favourite: 'There is no Node ORM period, for any tech. It's just not in Node culture'. -->

  <div>Sequelize</div>
  <!-- But I perservered, and discovered that Sequelize was the most popular option out there. Some of my friends were using it and said it wasn't so bad. It has over 700,000 downloads in the last month on npm. -->

  <div><img src="images/sequelize-1.png"></div>
  <!-- The Sequelize repo has 11k stars, LOTS of nice pretty badges, and activity as recent as a few days ago. 2.5k PRs have been merged, and the last issue was closed 2 days ago. -->

  <div><img src="images/sequelize-2.png"></div>
  <!-- The community seems pretty strong. 600 contributors, contributing docs, an editorconfig and a handy Dockerfile for running the repo locally. There's a Slack with over 2000 members, and the documentation is fairly extensive, even providing an example Express app. -->

  <div>
    <img src="images/me-trixie.png">
    <p>Me with a drag queen</p>
  </div>
  <!-- So let's try it out. To test out ORMs, I'm going to be combining my twin loves: JavaScript and drag queens. We're going to be building a JavaScript drag queen name generator. So we'll be taking a list of drag queen names, and a list of common JavaScript keywords, combining them to create a super-nerdy drag name. -->

  <div><img src="images/sequelize-queens.png"></div>
  <div><img src="images/sequelize-keywords.png"></div>
  <!-- So in our database, we want a table of drag queens, with their first and last names. And we want a table of JavaScript/Node terminology. In ORM-speak, we want "models" to interact with these tables: a Queen model, and a Keyword model. -->

  <div>
    <pre>
      <code>
        const sequelize = new Sequelize('dragqueens', 'michelle', 'pw', {
          dialect: 'postgres',
          pool: { max: 5, min: 0, idle: 10000 }
        });

        const Queen = sequelize.define('queen', {
          firstName: {
            type: Sequelize.STRING
          },
          lastName: {
            type: Sequelize.STRING
          }
        });

        const KeyWord = sequelize.define('keyword', {
          word: {
            type: Sequelize.STRING
          }
        });
      </code>
    </pre>
  </div>
  <!-- I managed to set up the database and define my models in 20 lines of code. Sequelize conveniently auto-generates the database tables for you which is handy. I passed in a array of drag queen names, and an array of JS keywords, and they were saved to the database. -->

  <div>
    <pre>
      <code>
        const queen = Queen.find({ order: [Sequelize.fn('RANDOM')] });
        const keyword = KeyWord.find({ order: [ Sequelize.fn('RANDOM')] });

        Promise.all([queen, keyword])
          .then(([q, k]) => {
            return `${q.firstName} ${k.word} ${q.lastName}`;
          });
      </code>
    </pre>
  </div>
  <div>The <em>Event Loop</em> Princess</div>
  <div>Lady <em>Blockchain</em> Bunny</div>
  <div>Jaidynn <em>Async Await</em> Diore Fierce</div>
  <!-- Now to generate the drag name. I used a handy "RANDOM" function inside the find method to just pull a name at random from the Queens table, and a word from the javascript keywords table. Sequelize is promise-based, which is nice. After the db call was done, I just put together a name string, and here we have our drag name. -->

  <div>All in all :+1:</div>
  <!-- I did find the docs a little patchy, which I remember from using Sequelize at work. I'd love more examples of using methods, especially chained together. But all in all, I think it was a pretty good experience using this module. -->

  <!-- bookshelf -->

  <div>Bookshelf üìö</div>
  <!-- But can we beat that with something more "lightweight"? Let's look at our alternative package, Bookshelf, which was a frequent suggestion in various forums. I think the name is cute. -->

  <div>"Lightweight ORM for Node.js"</div>
  <div>Minimalism</div>
  <div>
    <pre>
      <code>
        <em>const</em> Queen = sequelize.define('queen', {
          firstName: {
            type: Sequelize.STRING
          },
          lastName: {
            type: Sequelize.STRING
          }
        });
      </code>
    </pre>
  </div>
  <div>
    <pre>
      <code>
        const Queen = bookshelf.Model.extend({
          tableName: 'queens'
        });
      </code>
    </pre>
  </div>
  <!-- Bookshelf bills itself as a lightweight ORM for Node.js, built on top of the Knex SQL query builder. According to the internet, its big drawcard is its minimalism. It's a lot less opinionated than Sequelize. For example, it doesn't force you to describe the schema of your table in a model definition. This is what it looked like when I defined my models in Bookshelf. I did it in about half as many lines. -->

  <div><img src="images/bookshelf-3.png"></div>
  <div><img src="images/bookshelf-1.png"></div>
  <!-- I haven't looked at the repo in awhile, so let's revisit. The Bookshelf repo has 4000 stars, and was last updated 5 days ago. The badges are red and yellow which is concerning. I'd look into the issues and PRs, but something in the README immediately catches my attention: a big link that says "Read the discussion about the future of bookshelf.js". Hmm. -->

  <!-- Reading the thread about the future of Bookshelf, I unfortunately gather that the project is not in the best state. The original creator of the library has handed it over to a community organisation, and whilst there seem to be lots of people interested in developing it, there are some big problems that still need to be solved. Namely: a lack of experienced core contributors, a huge backlog of issues and PRs, documentation that's out of sync with the library itself, and code quality issues like intermittent failing builds and technical debt. -->

  <div>:(</div>
  <!-- This makes me pretty sad :( I was really getting into Bookshelf. It even had handy Lodash methods to generate my drag queen name with. -->

  <div>Sequelize or Bookshelf?</div>
  <div><img src="images/bookshelf-pr.png"></div>
  <div>The popular module wins!</div>
  <!-- So what's the verdict? I see the benefits of Bookshelf. It's a lot more intuitive to use, with less syntax to get through. I liked that it was handsoff with things like setting up the tables and validating the schema. But the lack of clarity about its future is kind of hard to get past. If I were building something just for myself, I would absolutely use Bookshelf. But for a production website that will be accessed by millions of users, the risk is too great. I'm really rooting for it, so much so I even made a pull request and became a contributor! -->

  <div>
    <h3>More alternatives:</h3>
    <ul style="margin-top: 20px;">
      <li>Use Lodash? Try <em>Lazy.js.</em></li>
      <li>Use Request? Try <em>Got.</em></li>
      <li>Use Winston? Try <em>Bunyan.</em></li>
    </ul>
  </div>
  <!-- Thanks for sticking with me in those two comparisons. There are so many more lightweight alternatives to popular modules that it would be fun to explore. Here are some of my suggestions. If you have the time, it's really worth exploring and not always going for the obvious option. -->

  <div>
    <h3>What I learned:</h3>
    <ul style="margin-top: 20px;">
      <li>Sometimes it's worth exploring less popular alternatives.</li>
      <li>Dependencies have a technical and human cost, and you should consider both.</li>
      <li>Well-maintained projects are almost always the better option.</li>
    </ul>
  </div>
  <!-- So. What have I learned about choosing my npm modules? These were my key takeaways:
    - Dependencies have a technical and human cost, and you should consider both
    - Well-maintained projects are almost always the better option
  -->

  <div>
    <h3>Useful tools:</h3>
    <ul style="margin-top: 20px;">
      <li><em>npmcompare.com</em> (popularity and maintenance)</li>
      <li><em>npmtrends.com</em> (popularity over time)</li>
      <li><em>david.dm</em> (security of dependencies)</li>
      <li><em>cost-of-modules</em> (size of dependencies)</li>
    </ul>
  </div>
  <!-- If you're looking for some ways to evaluate packages without digging through the repos yourself, I recommend the following tools:
    - npmcompare.com (for a top level overview of popularity and maintenance)
    - npmtrends.com (to see popularity over time)
    - David.dm (for checking the security of a project's dependencies)
    - cost-of-modules (npm package to tell you size of all your modules and their dependencies)
  -->

  <div>jsdrag.now.sh</div>
  <!-- I've put my JavaScript drag queen name generator online, using the Sequelize code. If you're looking to generate your own JavaScript drag queen name, you can go to bit.ly/jsdragqueen, and claim yours right now. -->

  <div>
    <em>Thank you!</em>
    <p>@msmichellegar</p>
  </div>
  <!-- Thanks everyone! -->
  <script src="highlight.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
    console.log('fmewiofmewio')
  </script>
</body>
</html>
